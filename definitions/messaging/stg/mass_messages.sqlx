config {
  type: "incremental",
  schema: "eros_messaging_stg", 
  uniqueKey: ["message_sk"],
  partitionBy: "sending_date",
  clusterBy: ["username_std"],
  requirePartitionFilter: true,
  description: "Incremental mass messages with 14-day watermark",
  labels: {app: "eros", domain: "messaging", layer: "stg"},
  tags: ["messaging_stg"]
}

WITH 
messages_unioned AS (
  SELECT 
    message_id,
    sender,
    sending_time,
    price,
    sent,
    viewed,
    purchased,
    earnings,
    message as message_text,
    'historical' as source_file
  FROM ${ref("facts_messages_all")}

  UNION ALL

  SELECT
    message_id,
    sender,
    sending_time,
    price,
    sent,
    viewed,
    purchased,
    earnings,
    message_text,
    'daily' as source_file
  FROM ${ref("mass_message_daily_final")}
),

messages_cleaned AS (
  SELECT
    FARM_FINGERPRINT(CONCAT(message_id, '_', source_file)) as message_sk,
    LOWER(TRIM(sender)) as username_std,
    -- Robustly parse multiple timestamp formats
    COALESCE(
      SAFE.PARSE_TIMESTAMP('%Y-%m-%dT%H:%M:%E*S%Ez', sending_time),
      SAFE.PARSE_TIMESTAMP('%Y-%m-%d %H:%M:%S', sending_time)
    ) as sending_ts,
    SAFE_CAST(REGEXP_REPLACE(CAST(price AS STRING), r'[$,]', '') AS FLOAT64) as price,
    SAFE_CAST(sent AS FLOAT64) as sent_count,
    SAFE_CAST(viewed AS FLOAT64) as viewed_count,
    SAFE_CAST(purchased AS FLOAT64) as purchased_count, 
    SAFE_CAST(REGEXP_REPLACE(CAST(earnings AS STRING), r'[$,]', '') AS FLOAT64) as earnings_total,
    message_text,
    source_file,
    CURRENT_TIMESTAMP() as loaded_at
  FROM messages_unioned
),

messages_final AS (
  SELECT
    *,
    DATE(sending_ts) as sending_date
  FROM messages_cleaned
  WHERE sending_ts IS NOT NULL
)

SELECT * FROM messages_final
WHERE sending_date >= '2024-01-01'
  
${ when(incremental(), `
  AND sending_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 14 DAY)
  AND sending_ts > (SELECT MAX(sending_ts) FROM ${self()})
`) }

QUALIFY ROW_NUMBER() OVER (
  PARTITION BY message_sk 
  ORDER BY loaded_at DESC
) = 1